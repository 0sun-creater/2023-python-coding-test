1. [특정 거리의 도시 찾기](#3.-특정-거리의-도시-찾기)
2. [괄호 변환](#6.-괄호-변환)
3. [연산자 끼워넣기](#7.-연산자-끼워넣기)
4. [블록 이동](#10.-블록-이동)
[](#)
[](#)
---


### 3. 특정 거리의 도시 찾기
- `sys.stdin.readline().rstrip().split()` 사용 안하면 시간초과 뜸
- 하나씩 방문하면서 depth 조사하고, K depth 가진 노드 모두 출력함.

<br>

### 6. 괄호 변환
- 재귀 함수 형식을 더 깔끔하게 할 수 있다.

```python
def solution(p):
  if p=='': return p
  r=True; c=0
  for i in range(len(p)):
      if p[i]=='(': c-=1
      else: c+=1
      if c>0: r=False
      if c==0:
          if r:
              return p[:i+1]+solution(p[i+1:])
          else:
              return '('+solution(p[i+1:])+')'+''.join(list(map(lambda x:'(' if x==')' else ')',p[1:i]) ))
```
<br>

### 7. 연산자 끼워넣기
- `permutations` 로 연산자 순열 구해서 진행하면 `시간 초과`
- 순열은 시간 복잡도가 `O(n!)` 이기 때문에 1초 제한일 때 최대 10까지 가능함

- 파이썬에서 초당 2천만번 연산 가능하다고 가정하는 것이 좋음
```
O(NlogN) : 100,000
O(N^2)   : 2,000
O(N^3)   : 500
O(N!)    : 10
```
<br>

### 10. 블록 이동
- 최단경로와 비슷하므로 bfs로 현재 위치에서 이동 가능한 로봇의 위치 넣기
- 이미 로봇이 위치해서 확인한 경우를 (위치1, 위치2) 형태로 저장하기 
  -> set 타입을 사용해야 시간초과 나지 않음
  - list 에서 `in 연산자`의 시간 복잡도는 `O(N)`
  - set 또는 dict 에서 `in 연산자`의 시간 복잡도는 `O(1)`

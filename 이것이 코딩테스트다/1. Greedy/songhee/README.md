### 당장 좋은 것만 선택하는 그리디 

- 그리디 Greedy 알고리즘은 단순하지만 강력한 문제 해결 방법
- 매 순간 가장 좋아보이는 것을 선택하고, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
- 사전 지식 없이도 풀 수 있을 가능성이 높은 문제 유형이지만 문제 유형이 다양해 항상 잘 풀 수 있지는 않다.

<br><br>


### 코딩 테스트에서 출제되는 그리디 알고리즘 유형

- 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구

- '가장 큰 순서대로', '가장 작은 순서대로' 같은 기준을 알게 모르게 제시

  -> 이런 기준은 정렬 알고리즘과 사용했을 때 만족시킬 수 있어 대체로 정렬 알고리즘과 짝을 이뤄 출제 됨

<br>

- **다익스트라 최단 경로** 알고리즘과 **크루스칼** 알고리즘도 그리디 알고리즘에 속한다.

<br><br>


### 그리디 알고리즘의 정당성 🌟

- 그리디 해법이 정당한지 검토해야 한다.
- 단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토 


<br><br><br>


## 문제

### 큰 수의 법칙

- 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과해 더해질 수 없는 것이 이 법칙의 특징이다.

- 예를 들어 순서대로 2, 4, 5, 4, 6 으로 이루어진 배열이 있을 때, M이 8이고 K가 3이라고 가정하자.

  이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다. 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.

- 예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고 K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다.

  결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4 인 28이 도출된다.

- 배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.

  
<br>

#### < 입력 조건 >

- 첫째 줄에 N(2 <= N <= 1000), M(1 <= M <= 10000), K(1 <= K <= 10000) 의 자연수가 주어지며 각자연수는 공백으로 구분한다.

- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다.
  단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.
  입력으로 주어지는 K는 항상 M보다 작거나 같다.

  
<br>

#### < 출력 조건 >

- 첫째 줄에 동빈이의 큰수의 법칙에 따라 더해진 답을 출력한다.



---



### 숫자 카드 게임

- 숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.
  1. 숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다.
  2. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
  3. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.
  4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑를 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.


<br>

#### < 입력 조건 >

- 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다. (1 <= N, M <= 100)
- 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000 이하의 자연수이다.


<br>

#### < 출력 조건 >

- 첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.



---



### 1이 될 때 까지

- 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.
  1. N에서 1을 뺀다.
  2. N을 K로 나눈다.
- N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성하시오.


<br>

#### <입력 조건 >

- 첫째 줄에 N(2 <= N <= 100,000), K(2 <= K <= 100,000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.


<br>

#### <출력 조건 >

- 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.



---



### 모험가 길드 ⚠️

- 한 마을에 모험가가 N명 있습니다. 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다.
- N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요.


<br>

#### <입력 조건 >

- 첫번 째 줄에 모험가의 수 N이 주어집니다 (1 <= N <= 100,000)

- 둘째 줄에 각 모험가의 공포도 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분합니다.

  
<br>

#### <출력 조건 >

- 여행을 떠날 수 있는 그룹 수의 최댓값을 출력합니다.


<br>

#### Memo

- 처음에는 공포도가 작은 순서대로 정렬한 다음 해당 인원만큼 끊어서 그룹핑을 하려고 했으나, 
- 이 경우는 [2, 3] 처럼 묶일 수 있어 안된다!



---



### 곱하기 혹은 더하기

- 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요. 

- 단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.

  
<br>

#### <입력 조건 >

- 첫 번째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어집니다. ( 1<= S의 길이 <= 20)


<br>

#### <출력 조건 >

- 첫 째 줄에 만들어질 수 있는 가장 큰 수 출력하기


<br>

#### Memo

- 더하기를 해서 더 커지는 경우는 0과 1일 때이다.

  

---



### 문자열 뒤집기

- 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.

- 예를 들어 S=0001100 일 때,
  1. 전체를 뒤집으면 1110011이 된다.
  2. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.

​	하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.

- 문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.

  
<br>

#### <입력 조건 >

- 첫째 줄에 0과 1로만 이루어진 문자열 S가 주어진다. (S의 길이 < 1,000,000)

  
<br>

#### <출력 조건 >

- 첫째 줄에 다솜이가 해야 하는 행동의 최소 횟수 출력



---



### 만들 수 없는 금액 ⚠️

- N개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟값을 구하는 프로그램을 작성하세요.

<br>


#### <입력 조건 >

- 첫째 줄에는 동전의 개수를 나타내는 양의 정수 N이 주어집니다. (1<= N <= 1,000)
- 둘째 줄에는 각 동전의 화폐 단위를 나타내는 N개의 자연수가 주어지며, 각 자연수는 공백으로 구분합니다. 이때, 각 화폐 단위는 1,000,000 이하의 자연수입니다.

<br>


#### <출력 조건 >

- 첫째 줄에 주어진 동전들로 만들 수 없는 양의 정수 금액 중 최솟값을 출력합니다.


<br>

#### Memo

- 현재 상태를 1 ~ target-1 까지 모든 금액을 만들 수 있는 상태라고 볼 때, target 금액을 만들 수 있는지 확인하면 된다.
- 이때 매번 target인 금액도 만들 수 있는지(현재 확인하는 동전의 단위가 target 이하인지) 체크하는 것이다. 만약 해당 금액을 만들 수 있다면, target의 값을 업데이트(현재 상태를 업데이트)하면 된다.



---



### 볼링공 고르기

- A, B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다.
- 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다.
- 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. 예를 들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1, 3, 2, 3, 2일때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다.
- 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다.
  - (1번, 2번), (1번, 3번), (1번, 4번), (1번, 5번), (2번, 3번), (2번, 5번), (3번, 4번), (4번, 5번)
  - 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다.
- **N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요.**


<br>

#### <입력 조건 >

- 첫째 줄에 볼링공의 개수 N, 볼링 공의 최대 무게 M이 공백으로 구분되어 각자 자연수 형태로 주어집니다. (1 <= N <= 1,000, 1<= M <= 10)

- 둘째 줄에 각 볼링공의 무게 K가 공복으로 구분되어 순서대로 자연수 형태로 주어집니다. (1 <= K <= M)

  
<br>

#### <출력 조건 >

- 첫째 줄에 두 사람이 볼링공을 고르는 경우의 수를 출력합니다.


<br>

#### Memo

- nC2 - (중복 숫자의 조합 개수 xC2)
- 또는, ( 무게 x의 공 개수) x ( 무게 x보다 큰 공의 개수) 의 합으로도 계산할 수 있을 것 같다.



---



### 무지의 먹방 라이브

[[기본코드]](https://school.programmers.co.kr/learn/courses/30/lessons/42891)

- 회전판에 먹어야 할 N개의 음식이 있습니다. 각 음식에는 1부터 N까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요됩니다.
- 무지는 다음과 같은 방법으로 음식을 섭취합니다.
  - 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓습니다. 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 옵니다.
  - **무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취합니다.** 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말합니다.
  - 회전판이 다음 음식을 무지 앞으로 가져오는 데 걸리는 시간은 없다고 가정합니다.
- 무지가 먹방을 시작한 지 K초 후에 네트워크 장애로 인해 방송이 잠시 중단되었습니다. **무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 합니다.**
- 각 음식을 모두 먹는 데 필요한 시간이 담겨 있는 배열 food_times, 네트워크 장애가 발생한 시간 K초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하세요.


<br>

#### <제한 사항 >

- food_times는 각 음식을 모두 먹는 데 필요한 시간이 음식의 번호 순서대로 들어 있는 배열입니다.
- k는 방송이 중단된 시간을 나타냅니다.
- 만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 됩니다.



---




'''
[설명]
- 못생긴 수는 오직 2, 3, 5만을 소인수(Prime Factor)로 가지는 수를 의미한다.
- 즉, 오직 2, 3, 5를 약수로 가지는 합성수를 의미한다.
- 1은 못생긴 수로 가정한다.
- 따라서 못생긴 수들은 {1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ...} 순으로 이어지게 된다.
- 이때, n번째 못생긴 수를 찾아라.

[아이디어]
- 못생긴 수에 2, 3, 5를 곱하면 이 또한 못생긴 수가 된다.
- 초기 dp 리스트에 1을 넣는다.
- 리스트에서 가장 작은 수를 뽑아서 2, 3, 5를 곱한수를 리스트에 넣는다.
- 또 다시 리스트에서 가장 작은 수를 뽑아서 2, 3, 5를 곱한수를 리스트의 적절한 위치에 넣는다.(오름차순에 맞게)

[점화식]
- dp[i] = i번째 못생긴 수

-> ✅ 다시풀기
'''

import sys
from heapq import heappush, heappop

n = int(input())

# DP 테이블 초기화
dp = [0] * n # 못생긴 수를 담는 리스트
dp[0] = 1 # 첫 번째 못생긴 수는 1

# 2배, 3배, 5배를 위한 인덱스
i2 = i3 = i5 = 0
# 처음에 곱셈값을 초기화
n2, n3, n5 = 2, 3, 5

# 1부터 n까지의 못생긴 수를 찾기
for l in range(1, n):
    
    # 가장 작은 곱셈수를 선택
    dp[l] = min(n2, n3, n5)
    
    # 인덱스에 따라 곱셈 결과를 증가
    if dp[l] == n2:
        i2 += 1
        n2 = dp[i2] * 2
    if dp[l] == n3:
        i3 += 1
        n3 = dp[i3] * 3
    if dp[l] == n5:
        i5 += 1
        n5 = dp[i5] * 5

# 출력
print(dp[n - 1])
'''
[설명]
- 개미전사는 식량창고를 약탈하는데, 서로 인접하지 않은 식량창고를 약탈해야 한다.
- 식량창고가 일직선상일 때 최대한 많은 식량을 얻기를 원한다.
- 식량창고를 털었을 때 얻을 수 있는 식량의 최댓값을 구하라.

[아이디어]
- 현재 식량창고는 i번째 식량창고라고 가정.
    - i번째는 0 ~ (i - 1)번째 식량창고를 털었는지 안털었는지에 영향을 받는다.
    - i - 1 번째는 0 ~ (i - 2)번째 식량창고를 털었는지 안털었는지에 영향을 받는다.
    
    -> 즉, 현재 식량창고는 이전(왼쪽) 식량창고를 터는지 안터는지에 따라 값이 달라진다.
- 현재 i번째 식량창고를 안턴다고 하면, 
    - i번째 식량창고의 식량의 최댓값은 i - 1 번째 식량창고를 털었을 때 얻을 수 있는 식량의 최댓값이 된다.
- 현재 i번째 식량창고를 턴다고 하면,
    - i - 1 번째는 인접한 식량창고이므로 털지 못하므로, i - 2 번째 식량창고를 털었을 때 얻을 수 있는 식량의 최댓값이 된다.

-> 따라서, i - 1번째, i - 2번째 중 더 많이 털 수 있는 경우를 선택하면 된다.

[점화식]
- dp[i] = max(dp[i - 1], dp[i - 2] + food_storages[i])
    -> i - 1번째를 터는 경우와 (현재 창고를 털고 i - 2번째도 터는 경우) 중 최댓값
'''

import sys

n = int(input())
food_storages = list(map(int, input().split()))

dp = [0] * n # i번째 식량창고를 털 때 얻을 수 있는 식량의 최댓값
dp[0] = food_storages[0]
dp[1] = max(food_storages[0], food_storages[1]) # 0번째가 1번째 보다 값이 더 클 수 있으므로

# Bottom-Up
for i in range(2, n):
    dp[i] = max(dp[i - 1], dp[i - 2] + food_storages[i]) 

print(dp[n - 1])
'''
[문제]
- 매 초마다 두 개의 나무 중 하나의 나무에서 열매가 떨어진다.
- 열매가 떨어지는 순간, 자두가 그 나무의 아래에 서 있으면 자두는 그 열매를 먹을 수 있다.
    -> 즉, 현재 위치한 나무의 아래에 열매가 떨어지면 자두는 그 열매를 먹을 수 있다.
    -> 떨어지는 순간 이동해서 자두를 먹을 수는 없다.
    
- 하나의 나무 아래에 서 있다가 다른 나무 아래로 빠르게 움직일 수 있다. 하지만 체력 때문에 많이 움직일 수는 없다.
- 자두는 T초 동안 떨어진다. 자두는 최대 W번만 움직이고 싶다.
- 자두는 처음에 1번 나무 아래에 위치해 있다.
- 자두가 받을 수 있는 자두의 개수를 구하라.

[점화식]
- dp[t][w][현재 위치] : t초에 w번 이동했을 때 현재 위치에 있을 때 받을 수 있는 자두의 개수

'''

t, w = map(int, input().split())
plums = [int(input()) for _ in range(t)]

# dp[t][w][현재 위치] : t초에 w번 이동했을 때 현재 위치에 있을 때 받을 수 있는 자두의 개수
dp = [[[0 for _ in range(3)] for _ in range(w + 2)] for _ in range(t + 1)]

# 처음 떨어지는 자두가 1번 나무에 떨어지는 경우
if plums[0] == 1:
    dp[1][0][1] = 1
# 처음 떨어지는 자두가 2번 나무에 떨어지는 경우
else:
    dp[1][1][2] = 1

# 첫 번째 자두는 처리했으므로, 2초부터 t초까지
for i in range(2, t + 1):
    # 현재 자두가 떨어지는 나무의 위치
    cur_tree = plums[i - 1]
    
    for j in range(w + 1):
        # 1번 나무라면
        if cur_tree == 1: 
            # 1번 나무에 위치
            # max(i - 1초에 1번에서 움직이지 않은 경우, i - 1초에 2번에서 1번으로 이동한 경우)
            dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][2]) + 1
            
            # 2번 나무에 위치
            # max(i - 1초에 1번에서 2번으로 이동한 경우, i - 1초에 2번에서 움직이지 않은 경우)
            dp[i][j][2] = max(dp[i - 1][j - 1][1], dp[i - 1][j][2])
        # 2번 나무라면
        else:
            # 1번 나무에 위치
            # max(i - 1초에 1번에서 움직이지 않은 경우, i - 1초에 2번에서 1번으로 이동한 경우)
            dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][2])
            
            # 2번 나무에 위치
            # max(i - 1초에 1번에서 2번으로 이동한 경우, i - 1초에 2번에서 움직이지 않은 경우)
            dp[i][j][2] = max(dp[i - 1][j - 1][1], dp[i - 1][j][2]) + 1

ret = 0
# 움직인 횟수에 따라 먹을 수 있는 자두의 최대 개수를 구한다.
for i in range(w + 1):
    ret = max(ret, max(dp[t][i][1], dp[t][i][2]))
    
print(ret)